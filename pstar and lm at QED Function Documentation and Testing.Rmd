---
title: "metapop.size.at.QED Documentation and testing"
output: html_notebook
---

This function finds the metapopulation size at equilibrium, given a species with a within patch extinction rate (e.rate), patch colonization rate (c.rate), extent to which it's dispersal is directional due to currents (gamma), extent to which the patches are connected by currents (epsilon), whether or not self recruitment can occur at a patch (self rec) and 1/(average dispersal distance) (alpha), for each landscape configuration. Then weights our expected metapopulation size at equilibrium by the time spent in (and/or probability of) that configuration at the calculated QED given a number of patches (N) turning on at rate r1 and off at rate r2.



```{r}
#Finds the equilibrium metapopulation size for each configuration
###############################################################################
lm.n.pstar.QED<-function(landscape, e.rate, c.rate, gamma, epsilon, self.rec, alpha, r1, r2){
  
  #calculate the extinction rate for each patch
  #extinction.rates<-e.rate/areas #if want this to be patch dependent
  #calculate delta
  delta<-e.rate/c.rate
  
  lambda.M<-rep(0,2^n.patches)
  metapop.size<-rep(0,2^n.patches)
  
  #equilibrium metapopulation size: for each possible configuration
  #####################################################################################################
  for (i in 0:((2^n.patches)-1)){
    bin.val<-intToBin(i) #obtain the binary representation of i 
    bin.val<-strsplit(bin.val,"")
    config<-rep(0,n.patches)
    for (k in 1:length(bin.val[[1]])){ #for each binary digit in i
      config[length(bin.val[[1]])-k+1]<-as.numeric(as.character(bin.val[[1]][k]))}

    if (i==0){
      #when i=0, it's the config where everything is turned off 
      #so pulling out the matrix elements doesn't work
      lambda.M[i+1]<-0
      metapop.size[i+1]<-0
    } else { #if i is not zero
      ####################################################
      landscape.config<-landscape[config!=0,]
      lambda.M[i+1]<-get.lambda.M(landscape.config, alpha, gamma, epsilon, self.rec, e.rate, c.rate)*delta 
      
      #calculate the persistence capacity within that configuration
      if(lambda.M[i+1]<delta){metapop.size[i+1]<-0 #if the persistence capacity is
      #below the extinction threshold, then the metapopultion is extinct, set size = 0
      } else {
        metapop.size[i+1]<-sum(pstar.function(landscape.config, alpha, delta, iterations=1000))
        #pstar gives expected occupancy of each patch at equilibrium, the total occupancy should be the sum
      }
    }
  }
  #get the time-averaged metapopulation sizes
  QED.output<-quasi.eq(n.patches, r1, r2)
  QED<-QED.output[[1]]#QED distribution
  T.absorp<-QED.output[[2]]#Time to absorption
  a.weighted.metapop.size<-dot(QED,metapop.size[2:2^n.patches]) #this is the expected metapop size in a given configuration x the porportion of time spent in it at QED and summed (therefore the arithmentic mean)
  #should actually be the geometric mean
  weighted.metapop.size<-exp(dot(QED,log(metapop.size[2:2^n.patches])))
  weighted.lm<-exp(dot(QED,log(lambda.M[2:2^n.patches])))
  return(list(weighted.metapop.size, weighted.lm, a.weighted.metapop.size))
}
```

TESTING
To be added...
